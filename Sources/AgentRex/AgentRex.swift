// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::774]]
import Foundation

// MARK: - Helper Types for Concurrency

/// Actor that tracks the latest values from two streams for combining.
actor LatestState<T: Sendable, U: Sendable> {
  var latest1: T?
  var latest2: U?
  
  func set1(_ value: T) -> (T, U)? {
    latest1 = value
    if let l1 = latest1, let l2 = latest2 {
      return (l1, l2)
    }
    return nil
  }
  
  func set2(_ value: U) -> (T, U)? {
    latest2 = value
    if let l1 = latest1, let l2 = latest2 {
      return (l1, l2)
    }
    return nil
  }
}

/// Actor for buffering with time windows.
actor TimeBuffer<T: Sendable> {
  var buffer: [T] = []
  
  func add(_ item: T) {
    buffer.append(item)
  }
  
  func flush() -> [T] {
    let items = buffer
    buffer = []
    return items
  }
}

/// Actor for eager pre-fetching buffer.
actor EagerBuffer<T: Sendable> {
  var items: [T] = []
  let maxSize: Int
  
  init(maxSize: Int) {
    self.maxSize = maxSize
  }
  
  func add(_ item: T) {
    if maxSize == 0 || items.count < maxSize {
      items.append(item)
    }
  }
  
  func pop() -> T? {
    items.isEmpty ? nil : items.removeFirst()
  }
  
  var isEmpty: Bool { items.isEmpty }
}

/// Sendable wrapper for functions.
struct SendableFunc<T, U>: @unchecked Sendable {
  let fn: (T) -> U
}

/// Actor for applyLatest state.
actor ApplyLatestState<T: Sendable, U: Sendable> {
  var latestFn: SendableFunc<T, U>?
  var latestValue: T?
  
  func setFn(_ fn: SendableFunc<T, U>) -> U? {
    latestFn = fn
    if let value = latestValue {
      return fn.fn(value)
    }
    return nil
  }
  
  func setValue(_ value: T) -> U? {
    latestValue = value
    if let fn = latestFn {
      return fn.fn(value)
    }
    return nil
  }
}

/// Actor to track a boolean flag for controlling task groups.
actor StopFlag {
  var stopped = false
  
  func stop() { stopped = true }
  func isStopped() -> Bool { stopped }
}

// MARK: - Stream Creators

/// Creates a stream that emits a single value and then completes.
public func just<T: Sendable>(_ value: T) -> AsyncStream<T> {
  AsyncStream { continuation in
    continuation.yield(value)
    continuation.finish()
  }
}

/// Alias for just
public func of<T: Sendable>(_ value: T) -> AsyncStream<T> {
  just(value)
}
// unnamed ends here

// [[file:index.org::1197]]
/// Creates a stream from an async operation.
/// When the operation completes, the stream emits the value and finishes.
public func fromAsync<T: Sendable>(_ operation: @Sendable @escaping () async throws -> T) -> AsyncThrowingStream<T, Error> {
  AsyncThrowingStream { continuation in
    Task {
      do {
        let value = try await operation()
        continuation.yield(value)
        continuation.finish()
      } catch {
        continuation.finish(throwing: error)
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::1543]]
/// Creates a stream from a sequence.
/// Emits each value from the sequence in order.
public func from<S: Sequence>(_ sequence: S) -> AsyncStream<S.Element> where S.Element: Sendable {
  AsyncStream { continuation in
    for item in sequence {
      continuation.yield(item)
    }
    continuation.finish()
  }
}

/// Creates a stream from an AsyncSequence.
public func from<S: AsyncSequence>(_ asyncSequence: S) -> AsyncStream<S.Element> where S: Sendable, S.Element: Sendable {
  AsyncStream { continuation in
    Task {
      do {
        for try await item in asyncSequence {
          continuation.yield(item)
        }
      } catch {
        // Silently finish on error for non-throwing variant
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::1854]]
/// Creates a stream that emits Void at regular intervals.
/// To give it a value, combine it with `constant`.
public func periodic(intervalNanoseconds: UInt64) -> AsyncStream<Void> {
  AsyncStream { continuation in
    Task {
      while !Task.isCancelled {
        continuation.yield(())
        try? await Task.sleep(nanoseconds: intervalNanoseconds)
      }
      continuation.finish()
    }
  }
}

/// Convenience overload for milliseconds.
public func periodic(intervalMs: UInt64) -> AsyncStream<Void> {
  periodic(intervalNanoseconds: intervalMs * 1_000_000)
}
// unnamed ends here

// [[file:index.org::2081]]
/// Creates a stream that immediately completes without emitting any values.
public func empty<T: Sendable>() -> AsyncStream<T> {
  AsyncStream { continuation in
    continuation.finish()
  }
}
// unnamed ends here

// [[file:index.org::2334]]
/// Creates a stream that never emits any values and never completes.
public func never<T: Sendable>() -> AsyncStream<T> {
  AsyncStream { _ in
    // Never yield, never finish â€” continuation kept alive indefinitely
  }
}
// unnamed ends here

// [[file:index.org::2639]]
/// Creates a stream that emits an infinite sequence by repeatedly applying a function.
public func iterate<T: Sendable>(_ seed: T, _ f: @Sendable @escaping (T) -> T) -> AsyncStream<T> {
  AsyncStream { continuation in
    let task = Task {
      var current = seed
      while !Task.isCancelled {
        continuation.yield(current)
        current = f(current)
        // Yield to allow cancellation to be processed
        await Task.yield()
      }
      continuation.finish()
    }
    
    continuation.onTermination = { _ in
      task.cancel()
    }
  }
}
// unnamed ends here

// [[file:index.org::3090]]
/// Result of an unfold step.
public struct UnfoldResult<T, S> {
  public let value: T
  public let nextSeed: S
  public let done: Bool
  
  public init(value: T, nextSeed: S, done: Bool) {
    self.value = value
    self.nextSeed = nextSeed
    self.done = done
  }
}

/// Creates a stream by unfolding a seed value.
public func unfold<T: Sendable, S: Sendable>(_ seed: S, _ f: @Sendable @escaping (S) -> UnfoldResult<T, S>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      var currentSeed = seed
      while !Task.isCancelled {
        let result = f(currentSeed)
        if result.done {
          break
        }
        continuation.yield(result.value)
        currentSeed = result.nextSeed
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::3409]]
/// Prepends a value to the beginning of a stream.
public func startWith<T: Sendable>(_ value: T, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      continuation.yield(value)
      for await item in stream {
        continuation.yield(item)
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::3786]]
/// Concatenates two streams into a single stream.
public func concat<T: Sendable>(_ s1: AsyncStream<T>, _ s2: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      for await item in s1 {
        continuation.yield(item)
      }
      for await item in s2 {
        continuation.yield(item)
      }
      continuation.finish()
    }
  }
}

/// Concatenates multiple streams into a single stream.
public func concat<T: Sendable>(_ streams: [AsyncStream<T>]) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      for stream in streams {
        for await item in stream {
          continuation.yield(item)
        }
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::4045]]
/// A channel that wraps AsyncStream continuation for thread-safe access.
public final class Channel<T: Sendable>: @unchecked Sendable {
  private let continuation: AsyncStream<T>.Continuation
  
  fileprivate init(_ continuation: AsyncStream<T>.Continuation) {
    self.continuation = continuation
  }
  
  public func send(_ value: T) {
    continuation.yield(value)
  }
  
  public func finish() {
    continuation.finish()
  }
}

/// Creates an AsyncStream along with a Channel to push values.
/// This is useful for bridging callback-based or event-based APIs.
///
/// Example:
/// ```swift
/// let (stream, channel) = createChannel<String>()
/// 
/// // In an event handler:
/// channel.send("event occurred")
/// 
/// // When done:
/// channel.finish()
/// ```
public func createChannel<T: Sendable>() -> (
  stream: AsyncStream<T>,
  channel: Channel<T>
) {
  var channel: Channel<T>!
  let stream = AsyncStream<T> { continuation in
    channel = Channel(continuation)
  }
  return (stream: stream, channel: channel)
}

/// Creates an AsyncStream from a callback-based API.
/// The setup closure receives functions to yield values and finish the stream.
public func fromCallback<T: Sendable>(
  _ setup: @escaping (@escaping (T) -> Void, @escaping () -> Void) -> Void
) -> AsyncStream<T> {
  AsyncStream { continuation in
    setup(
      { value in continuation.yield(value) },
      { continuation.finish() }
    )
  }
}
// unnamed ends here

// [[file:index.org::4659]]
/// Maps each value in a stream using a function.
public func map<T: Sendable, U: Sendable>(_ f: @Sendable @escaping (T) -> U, _ stream: AsyncStream<T>) -> AsyncStream<U> {
  AsyncStream { continuation in
    Task {
      for await item in stream {
        continuation.yield(f(item))
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func map<T: Sendable, U: Sendable>(_ f: @Sendable @escaping (T) -> U) -> @Sendable (AsyncStream<T>) -> AsyncStream<U> {
  { stream in map(f, stream) }
}
// unnamed ends here

// [[file:index.org::4844]]
/// Emits a constant value for each item in the source stream.
public func constant<T: Sendable, U: Sendable>(_ value: U, _ stream: AsyncStream<T>) -> AsyncStream<U> {
  AsyncStream { continuation in
    Task {
      for await _ in stream {
        continuation.yield(value)
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func constant<T: Sendable, U: Sendable>(_ value: U) -> @Sendable (AsyncStream<T>) -> AsyncStream<U> {
  { stream in constant(value, stream) }
}
// unnamed ends here

// [[file:index.org::5411]]
/// Accumulates values using an accumulator function, emitting each intermediate result.
/// Yields the seed first, then each accumulated value.
public func scan<T: Sendable, U: Sendable>(_ accumulator: @Sendable @escaping (U, T) -> U, _ seed: U, _ stream: AsyncStream<T>) -> AsyncStream<U> {
  AsyncStream { continuation in
    Task {
      var acc = seed
      continuation.yield(acc)
      for await item in stream {
        acc = accumulator(acc, item)
        continuation.yield(acc)
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func scan<T: Sendable, U: Sendable>(_ accumulator: @Sendable @escaping (U, T) -> U, _ seed: U) -> @Sendable (AsyncStream<T>) -> AsyncStream<U> {
  { stream in scan(accumulator, seed, stream) }
}
// unnamed ends here

// [[file:index.org::5759]]
/// Performs side effects for each value without modifying them.
/// The side effect is called synchronously (fire-and-forget for async effects).
public func tap<T: Sendable>(_ sideEffect: @Sendable @escaping (T) async -> Void, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      for await item in stream {
        await sideEffect(item)
        continuation.yield(item)
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func tap<T: Sendable>(_ sideEffect: @Sendable @escaping (T) async -> Void) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  { stream in tap(sideEffect, stream) }
}
// unnamed ends here

// [[file:index.org::6086]]
/// Performs side effects for each value, awaiting completion before yielding.
public func awaitTap<T: Sendable>(_ sideEffect: @Sendable @escaping (T) async -> Void, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      for await item in stream {
        await sideEffect(item)
        continuation.yield(item)
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func awaitTap<T: Sendable>(_ sideEffect: @Sendable @escaping (T) async -> Void) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  { stream in awaitTap(sideEffect, stream) }
}
// unnamed ends here

// [[file:index.org::6470]]
/// Continues with another stream after the first completes.
/// The continuation function is only called after the first stream finishes.
public func continueWith<T: Sendable>(_ f: @Sendable @escaping () -> AsyncStream<T>, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      for await item in stream {
        continuation.yield(item)
      }
      for await item in f() {
        continuation.yield(item)
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func continueWith<T: Sendable>(_ f: @Sendable @escaping () -> AsyncStream<T>) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  { stream in continueWith(f, stream) }
}
// unnamed ends here

// [[file:index.org::6772]]
/// Flattens a stream of streams by concatenating them into a single stream.
public func concatAll<T: Sendable>(_ streamOfStreams: AsyncStream<AsyncStream<T>>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      for await innerStream in streamOfStreams {
        for await item in innerStream {
          continuation.yield(item)
        }
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::7120]]
/// Maps each value to a stream and concatenates the results in order.
public func concatMap<T: Sendable, U: Sendable>(_ f: @Sendable @escaping (T) -> AsyncStream<U>, _ stream: AsyncStream<T>) -> AsyncStream<U> {
  AsyncStream { continuation in
    Task {
      for await item in stream {
        for await innerItem in f(item) {
          continuation.yield(innerItem)
        }
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func concatMap<T: Sendable, U: Sendable>(_ f: @Sendable @escaping (T) -> AsyncStream<U>) -> @Sendable (AsyncStream<T>) -> AsyncStream<U> {
  { stream in concatMap(f, stream) }
}
// unnamed ends here

// [[file:index.org::7552]]
/// Filters values in a stream based on a predicate.
public func filter<T: Sendable>(_ predicate: @Sendable @escaping (T) -> Bool, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      for await item in stream {
        if predicate(item) {
          continuation.yield(item)
        }
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func filter<T: Sendable>(_ predicate: @Sendable @escaping (T) -> Bool) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  { stream in filter(predicate, stream) }
}

/// Async predicate version.
public func filterAsync<T: Sendable>(_ predicate: @Sendable @escaping (T) async -> Bool, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      for await item in stream {
        if await predicate(item) {
          continuation.yield(item)
        }
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::8143]]
/// Filter consecutive duplicates using a custom equality function.
public func skipRepeatsWith<T: Sendable>(_ equals: @Sendable @escaping (T, T) -> Bool, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      var last: T?
      for await item in stream {
        let shouldYield: Bool
        if let prev = last {
          shouldYield = !equals(item, prev)
        } else {
          shouldYield = true
        }
        if shouldYield {
          last = item
          continuation.yield(item)
        }
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func skipRepeatsWith<T: Sendable>(_ equals: @Sendable @escaping (T, T) -> Bool) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  { stream in skipRepeatsWith(equals, stream) }
}

/// Filter consecutive duplicates using Equatable.
public func skipRepeats<T: Equatable & Sendable>(_ stream: AsyncStream<T>) -> AsyncStream<T> {
  skipRepeatsWith({ $0 == $1 }, stream)
}
// unnamed ends here

// [[file:index.org::8874]]
/// Skips the first n values from a stream.
public func skip<T: Sendable>(_ n: Int, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      var count = 0
      for await item in stream {
        if count >= n {
          continuation.yield(item)
        }
        count += 1
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func skip<T: Sendable>(_ n: Int) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  { stream in skip(n, stream) }
}
// unnamed ends here

// [[file:index.org::9262]]
/// Emits values from index start to end (exclusive).
public func slice<T: Sendable>(_ start: Int, _ end: Int, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      var index = 0
      for await item in stream {
        if index >= start && index < end {
          continuation.yield(item)
        }
        index += 1
        if index >= end { break }
      }
      continuation.finish()
    }
  }
}

/// Curried version for pipe-style composition.
public func slice<T: Sendable>(_ start: Int, _ end: Int) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  { stream in slice(start, end, stream) }
}
// unnamed ends here

// [[file:index.org::9651]]
/// Takes values from a stream while the predicate returns true.
/// Once the predicate returns false, the stream completes.
public func takeWhile<T: Sendable>(
  _ predicate: @Sendable @escaping (T) async -> Bool
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { stream in
    AsyncStream { continuation in
      Task {
        for await item in stream {
          if await predicate(item) {
            continuation.yield(item)
          } else {
            break
          }
        }
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::10048]]
/// Skips values from a stream while the predicate returns true.
/// Once the predicate returns false, all subsequent values are emitted.
public func skipWhile<T: Sendable>(
  _ predicate: @Sendable @escaping (T) async -> Bool
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { stream in
    AsyncStream { continuation in
      Task {
        var skipping = true
        for await item in stream {
          if skipping {
            if !(await predicate(item)) {
              skipping = false
              continuation.yield(item)
            }
          } else {
            continuation.yield(item)
          }
        }
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::10439]]
/// Emits values from a stream until the predicate returns true.
/// The matching value is NOT emitted (exclusive).
public func takeUntil<T: Sendable>(
  _ predicate: @Sendable @escaping (T) async -> Bool
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { stream in
    AsyncStream { continuation in
      Task {
        for await item in stream {
          if await predicate(item) {
            break
          }
          continuation.yield(item)
        }
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::10677]]
/// Delays each emission by the specified duration in milliseconds.
public func delay<T: Sendable>(
  _ delayMs: UInt64
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { stream in
    AsyncStream { continuation in
      Task {
        for await item in stream {
          try? await Task.sleep(nanoseconds: delayMs * 1_000_000)
          continuation.yield(item)
        }
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::11384]]
/// Actor to manage debounce state.
actor DebounceState<T: Sendable> {
  var latestValue: T?
  
  func set(_ value: T) {
    latestValue = value
  }
  
  func get() -> T? {
    latestValue
  }
}

/// Only emits a value if no new values arrive within the specified duration.
/// Waits for the stream to "settle" before emitting the most recent value.
public func debounce<T: Sendable>(
  _ durationMs: UInt64
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { stream in
    AsyncStream { continuation in
      Task {
        let state = DebounceState<T>()
        var debounceTask: Task<Void, Never>?
        
        for await item in stream {
          await state.set(item)
          debounceTask?.cancel()
          debounceTask = Task {
            try? await Task.sleep(nanoseconds: durationMs * 1_000_000)
            if !Task.isCancelled, let value = await state.get() {
              continuation.yield(value)
            }
          }
        }
        
        // Wait for final debounce to complete
        await debounceTask?.value
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::12077]]
/// Options for throttle behavior.
public struct ThrottleOptions: Sendable {
  public let leading: Bool
  public let trailing: Bool
  
  public init(leading: Bool = true, trailing: Bool = true) {
    self.leading = leading
    self.trailing = trailing
  }
  
  public static func leadingOnly() -> ThrottleOptions {
    ThrottleOptions(leading: true, trailing: false)
  }
  
  public static func trailingOnly() -> ThrottleOptions {
    ThrottleOptions(leading: false, trailing: true)
  }
}

/// Limits the rate of emissions with leading and trailing options.
public func throttle<T: Sendable>(
  _ durationMs: UInt64,
  _ options: ThrottleOptions = ThrottleOptions()
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { stream in
    AsyncStream { continuation in
      Task {
        var lastEmitTime: ContinuousClock.Instant?
        var pendingTrailing: T?
        let duration = Duration.milliseconds(Int64(durationMs))
        
        for await item in stream {
          let now = ContinuousClock.now
          
          if let lastTime = lastEmitTime {
            let elapsed = now - lastTime
            if elapsed >= duration {
              if options.leading {
                continuation.yield(item)
                lastEmitTime = now
                pendingTrailing = nil
              } else {
                pendingTrailing = item
              }
            } else {
              pendingTrailing = item
            }
          } else {
            // First item
            if options.leading {
              continuation.yield(item)
              lastEmitTime = now
            } else {
              pendingTrailing = item
              lastEmitTime = now
            }
          }
        }
        
        // Emit trailing if configured and there's a pending value
        if options.trailing, let trailing = pendingTrailing {
          continuation.yield(trailing)
        }
        
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::12622]]
/// Recovers from errors in a throwing stream by providing a fallback stream.
public func recoverWith<T: Sendable>(
  _ handler: @Sendable @escaping (any Error) -> AsyncStream<T>
) -> @Sendable (AsyncThrowingStream<T, any Error>) -> AsyncStream<T> {
  return { stream in
    AsyncStream { continuation in
      Task {
        do {
          for try await item in stream {
            continuation.yield(item)
          }
        } catch {
          let fallback = handler(error)
          for await item in fallback {
            continuation.yield(item)
          }
        }
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::12800]]
/// Recovers from errors using a sequence of alternative streams.
/// Each time an error occurs, the next alternative stream is used.
public func recoverWithStream<T: Sendable, Alts: AsyncSequence & Sendable>(
  _ alternatives: Alts
) -> @Sendable (AsyncThrowingStream<T, any Error>) -> AsyncStream<T>
where Alts.Element == AsyncStream<T> {
  return { source in
    AsyncStream { continuation in
      Task {
        var altIterator = alternatives.makeAsyncIterator()
        var currentStream: Any = source
        
        func consumeSource() async {
          do {
            for try await item in source {
              continuation.yield(item)
            }
          } catch {
            if let alt = try? await altIterator.next() {
              for await item in alt {
                continuation.yield(item)
              }
            }
          }
        }
        
        await consumeSource()
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::13077]]
/// Creates a stream that immediately throws the given error.
public func throwError<T: Sendable>(_ error: any Error) -> AsyncThrowingStream<T, any Error> {
  AsyncThrowingStream { continuation in
    continuation.finish(throwing: error)
  }
}
// unnamed ends here

// [[file:index.org::13790]]
/// Retries a stream factory up to maxAttempts times if it fails.
public func retry<T: Sendable>(
  _ maxAttempts: Int,
  delayMs: UInt64 = 0,
  _ factory: @Sendable @escaping () -> AsyncThrowingStream<T, any Error>
) -> AsyncStream<Result<T, any Error>> {
  AsyncStream { continuation in
    Task {
      var attempts = 0
      
      while attempts < maxAttempts {
        attempts += 1
        let stream = factory()
        var failed = false
        
        do {
          for try await item in stream {
            continuation.yield(.success(item))
          }
          // Stream completed successfully
          continuation.finish()
          return
        } catch {
          failed = true
          if attempts < maxAttempts && delayMs > 0 {
            try? await Task.sleep(nanoseconds: delayMs * 1_000_000)
          }
        }
        
        if !failed {
          continuation.finish()
          return
        }
      }
      
      // Exhausted all retries
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::14355]]
/// Merges two streams, emitting values from both concurrently.
public func merge<T: Sendable>(
  _ stream1: AsyncStream<T>,
  _ stream2: AsyncStream<T>
) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      await withTaskGroup(of: Void.self) { group in
        group.addTask {
          for await item in stream1 {
            continuation.yield(item)
          }
        }
        group.addTask {
          for await item in stream2 {
            continuation.yield(item)
          }
        }
      }
      continuation.finish()
    }
  }
}

/// Merges multiple streams, emitting values from all concurrently.
public func mergeAll<T: Sendable>(
  _ streams: [AsyncStream<T>]
) -> AsyncStream<T> {
  AsyncStream { continuation in
    Task {
      await withTaskGroup(of: Void.self) { group in
        for stream in streams {
          group.addTask {
            for await item in stream {
              continuation.yield(item)
            }
          }
        }
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::14943]]
/// Maps each value to a stream and flattens the results concurrently.
/// Also known as flatMap in some libraries.
public func chain<T: Sendable, U: Sendable>(
  _ fn: @Sendable @escaping (T) async -> AsyncStream<U>
) -> @Sendable (AsyncStream<T>) -> AsyncStream<U> {
  return { stream in
    AsyncStream { continuation in
      Task {
        await withTaskGroup(of: Void.self) { group in
          for await item in stream {
            let innerStream = await fn(item)
            group.addTask {
              for await innerItem in innerStream {
                continuation.yield(innerItem)
              }
            }
          }
        }
        continuation.finish()
      }
    }
  }
}

/// Alias for chain.
public func flatMap<T: Sendable, U: Sendable>(
  _ fn: @Sendable @escaping (T) async -> AsyncStream<U>
) -> @Sendable (AsyncStream<T>) -> AsyncStream<U> {
  chain(fn)
}
// unnamed ends here

// [[file:index.org::15663]]
/// Maps each value to a stream, canceling the previous inner stream when a new value arrives.
public func switchMap<T: Sendable, U: Sendable>(
  _ fn: @Sendable @escaping (T) async -> AsyncStream<U>
) -> @Sendable (AsyncStream<T>) -> AsyncStream<U> {
  return { stream in
    AsyncStream { continuation in
      Task {
        var currentTask: Task<Void, Never>?
        
        for await item in stream {
          currentTask?.cancel()
          let innerStream = await fn(item)
          currentTask = Task {
            for await innerItem in innerStream {
              if Task.isCancelled { break }
              continuation.yield(innerItem)
            }
          }
        }
        
        // Wait for last inner stream to complete
        await currentTask?.value
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::16092]]
/// Combines two streams, emitting tuple of latest values whenever either emits.
/// Only starts emitting after both streams have produced at least one value.
public func latest<T: Sendable, U: Sendable>(
  _ stream1: AsyncStream<T>,
  _ stream2: AsyncStream<U>
) -> AsyncStream<(T, U)> {
  AsyncStream { continuation in
    Task {
      let state = LatestState<T, U>()
      
      await withTaskGroup(of: Void.self) { group in
        group.addTask {
          for await item in stream1 {
            if let pair = await state.set1(item) {
              continuation.yield(pair)
            }
          }
        }
        group.addTask {
          for await item in stream2 {
            if let pair = await state.set2(item) {
              continuation.yield(pair)
            }
          }
        }
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::16357]]
/// Applies the latest function from a stream of functions to the latest value from a stream of values.
public func applyLatest<T: Sendable, U: Sendable>(
  _ fnStream: AsyncStream<@Sendable (T) -> U>,
  _ valueStream: AsyncStream<T>
) -> AsyncStream<U> {
  let wrappedFnStream = AsyncStream<SendableFunc<T, U>> { continuation in
    Task {
      for await fn in fnStream {
        continuation.yield(SendableFunc(fn: fn))
      }
      continuation.finish()
    }
  }
  
  return AsyncStream { continuation in
    Task {
      let state = ApplyLatestState<T, U>()
      
      await withTaskGroup(of: Void.self) { group in
        group.addTask {
          for await fn in wrappedFnStream {
            if let result = await state.setFn(fn) {
              continuation.yield(result)
            }
          }
        }
        group.addTask {
          for await value in valueStream {
            if let result = await state.setValue(value) {
              continuation.yield(result)
            }
          }
        }
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::16736]]
/// Emits values from source until the stop stream emits any value.
public func untilStream<T: Sendable, S: Sendable>(
  _ stop: AsyncStream<S>
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { source in
    AsyncStream { continuation in
      Task {
        let flag = StopFlag()
        
        await withTaskGroup(of: Void.self) { group in
          group.addTask {
            for await _ in stop {
              await flag.stop()
              break
            }
          }
          
          group.addTask {
            for await item in source {
              if await flag.isStopped() { break }
              continuation.yield(item)
            }
          }
          
          group.cancelAll()
        }
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::17105]]
/// Starts emitting values from source only after the start stream emits a value.
public func sinceStream<T: Sendable, S: Sendable>(
  _ start: AsyncStream<S>
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { source in
    AsyncStream { continuation in
      Task {
        // Wait for the start signal
        for await _ in start {
          break
        }
        
        // Now emit all remaining source values
        for await item in source {
          continuation.yield(item)
        }
        
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::17462]]
/// Collects values into buffers of the specified size.
public func buffer<T: Sendable>(
  _ size: Int
) -> @Sendable (AsyncStream<T>) -> AsyncStream<[T]> {
  return { stream in
    AsyncStream { continuation in
      Task {
        var currentBuffer: [T] = []
        
        for await item in stream {
          currentBuffer.append(item)
          if currentBuffer.count >= size {
            continuation.yield(currentBuffer)
            currentBuffer = []
          }
        }
        
        // Emit any remaining items
        if !currentBuffer.isEmpty {
          continuation.yield(currentBuffer)
        }
        
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::17928]]
/// Collects values over a time window, emitting the buffer when the window closes.
public func bufferTime<T: Sendable>(
  _ durationMs: UInt64
) -> @Sendable (AsyncStream<T>) -> AsyncStream<[T]> {
  return { stream in
    AsyncStream { continuation in
      Task {
        let state = TimeBuffer<T>()
        let stopFlag = StopFlag()
        let duration = Duration.milliseconds(Int64(durationMs))
        
        await withTaskGroup(of: Void.self) { group in
          // Timer task
          group.addTask {
            while await !stopFlag.isStopped() {
              try? await Task.sleep(for: duration)
              let items = await state.flush()
              if !items.isEmpty {
                continuation.yield(items)
              }
            }
          }
          
          // Source consuming task
          group.addTask {
            for await item in stream {
              await state.add(item)
            }
            await stopFlag.stop()
            // Flush remaining
            let remaining = await state.flush()
            if !remaining.isEmpty {
              continuation.yield(remaining)
            }
          }
        }
        
        continuation.finish()
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::18289]]
/// Splits the source into windows of the specified size.
/// Similar to buffer, but each window could be a stream (simplified to arrays here).
public func window<T: Sendable>(
  _ size: Int
) -> @Sendable (AsyncStream<T>) -> AsyncStream<[T]> {
  // In Swift, we simplify to returning arrays like the Rust implementation
  buffer(size)
}
// unnamed ends here

// [[file:index.org::18867]]
/// Pre-fetches values from a slow producer into a buffer.
/// Starts buffering when the first value is requested.
public func eager<T: Sendable>(
  _ bufferSize: Int
) -> @Sendable (AsyncStream<T>) -> AsyncStream<T> {
  return { source in
    AsyncStream { continuation in
      Task {
        let buffer = EagerBuffer<T>(maxSize: bufferSize)
        
        // Background task to fill buffer
        let fillTask = Task {
          for await item in source {
            await buffer.add(item)
          }
        }
        
        // Small delay to let buffer fill
        try? await Task.sleep(nanoseconds: 1_000_000)
        
        // Drain buffer and continue with source
        while let item = await buffer.pop() {
          continuation.yield(item)
        }
        
        await fillTask.value
        continuation.finish()
      }
    }
  }
}

/// Pre-fetches values immediately on creation.
public func eagerNow<T: Sendable>(
  _ bufferSize: Int,
  _ source: AsyncStream<T>
) -> AsyncStream<T> {
  eager(bufferSize)(source)
}
// unnamed ends here

// [[file:index.org::19344]]
/// A multicasting primitive that buffers recent values and replays them to new subscribers.
public actor ReplaySubject<T: Sendable> {
  private var buffer: [T] = []
  private let bufferSize: Int
  private var completed = false
  private var continuations: [AsyncStream<T>.Continuation] = []
  
  public init(bufferSize: Int) {
    self.bufferSize = bufferSize
  }
  
  /// Sends a value to all current subscribers and buffers it.
  public func next(_ value: T) {
    guard !completed else { return }
    
    // Add to buffer, evict if full
    buffer.append(value)
    if bufferSize > 0 && buffer.count > bufferSize {
      buffer.removeFirst()
    }
    
    // Send to all active subscribers
    for continuation in continuations {
      continuation.yield(value)
    }
  }
  
  /// Marks the subject as complete.
  public func complete() {
    completed = true
    for continuation in continuations {
      continuation.finish()
    }
    continuations.removeAll()
  }
  
  /// Creates a new subscription that receives buffered values and future emissions.
  public func subscribe() -> AsyncStream<T> {
    AsyncStream { continuation in
      // Send buffered values
      for item in buffer {
        continuation.yield(item)
      }
      
      if completed {
        continuation.finish()
      } else {
        continuations.append(continuation)
      }
    }
  }
}
// unnamed ends here

// [[file:index.org::19937]]
/// Actor to manage Replay's startup state.
actor ReplayState {
  var started = false
  
  func startIfNeeded() -> Bool {
    if started { return false }
    started = true
    return true
  }
}

/// Wraps a source stream to allow multiple consumers with replay buffer.
public final class Replay<T: Sendable>: Sendable {
  private let subject: ReplaySubject<T>
  private let source: AsyncStream<T>
  private let state = ReplayState()
  
  public init(bufferSize: Int, _ source: AsyncStream<T>) {
    self.subject = ReplaySubject(bufferSize: bufferSize)
    self.source = source
  }
  
  /// Creates a subscription, starting source consumption on first call.
  public func subscribe() async -> AsyncStream<T> {
    let shouldStart = await state.startIfNeeded()
    
    if shouldStart {
      Task {
        for await item in source {
          await subject.next(item)
        }
        await subject.complete()
      }
    }
    
    return await subject.subscribe()
  }
}

/// Creates a replay wrapper for a stream.
public func replay<T: Sendable>(
  _ bufferSize: Int
) -> @Sendable (AsyncStream<T>) -> Replay<T> {
  return { source in
    Replay(bufferSize: bufferSize, source)
  }
}
// unnamed ends here

// [[file:index.org::20321]]
/// Like replay with buffer size 0. New subscribers only receive values emitted after subscription.
public func share<T: Sendable>(
  _ source: AsyncStream<T>
) -> Replay<T> {
  Replay(bufferSize: 0, source)
}
// unnamed ends here

// [[file:index.org::20743]]
/// Creates a factory that produces independent copies of a buffered stream.
public func replayFactory<T: Sendable>(
  _ bufferSize: Int,
  _ source: AsyncStream<T>
) -> @Sendable () async -> AsyncStream<T> {
  let replay = Replay(bufferSize: bufferSize, source)
  
  return {
    await replay.subscribe()
  }
}
// unnamed ends here

// [[file:index.org::20909]]
/// Returns a stream that emits independent copies of the source stream.
/// Each emitted stream is a fresh subscriber.
public func replayStream<T: Sendable>(
  _ bufferSize: Int,
  _ source: AsyncStream<T>
) -> AsyncStream<AsyncStream<T>> {
  let factory = replayFactory(bufferSize, source)
  
  return AsyncStream { continuation in
    Task {
      // Emit stream copies indefinitely
      while !Task.isCancelled {
        let copy = await factory()
        continuation.yield(copy)
      }
      continuation.finish()
    }
  }
}
// unnamed ends here

// [[file:index.org::23231]]
/// Takes at most N values from a stream, then finishes.
public func take<T: Sendable>(_ n: Int, _ stream: AsyncStream<T>) -> AsyncStream<T> {
  AsyncStream { continuation in
    let task = Task {
      var count = 0
      for await value in stream {
        if count >= n { break }
        continuation.yield(value)
        count += 1
      }
      continuation.finish()
    }
    
    continuation.onTermination = { _ in
      task.cancel()
    }
  }
}
// unnamed ends here
