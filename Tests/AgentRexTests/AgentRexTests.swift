// This file is auto-generated by organjsm tangle. Do not edit directly.
// Source: index.org

// [[file:index.org::891]]
import XCTest
@testable import AgentRex

final class AgentRexTests: XCTestCase {
  func testJustEmitsSingleValue() async throws {
    let values = await collect(just(42))
    XCTAssertEqual(values, [42])
  }

  func testOfIsAlias() async throws {
    let values = await collect(of("hello"))
    XCTAssertEqual(values, ["hello"])
  }
// unnamed ends here

// [[file:index.org::1217]]
  func testFromAsyncEmitsResolvedValue() async throws {
    let values = try await collectThrowing(fromAsync { 42 })
    XCTAssertEqual(values, [42])
  }

  func testFromAsyncWithAsyncComputation() async throws {
    let values = try await collectThrowing(fromAsync {
      try await Task.sleep(nanoseconds: 1_000_000)
      return "computed"
    })
    XCTAssertEqual(values, ["computed"])
  }
// unnamed ends here

// [[file:index.org::1574]]
  func testFromEmitsAllValues() async throws {
    let values = await collect(from([1, 2, 3]))
    XCTAssertEqual(values, [1, 2, 3])
  }

  func testFromHandlesEmpty() async throws {
    let values: [Int] = await collect(from([]))
    XCTAssertTrue(values.isEmpty)
  }

  func testFromWithRange() async throws {
    let values = await collect(from(0..<5))
    XCTAssertEqual(values, [0, 1, 2, 3, 4])
  }
// unnamed ends here

// [[file:index.org::1877]]
  func testPeriodicEmitsAtIntervals() async throws {
    let values = await collect(take(3, periodic(intervalMs: 10)))
    XCTAssertEqual(values.count, 3)
  }
// unnamed ends here

// [[file:index.org::2092]]
  func testEmptyCompletesImmediately() async throws {
    let values: [Int] = await collect(empty())
    XCTAssertTrue(values.isEmpty)
  }
// unnamed ends here

// [[file:index.org::2345]]
  func testNeverDoesNotComplete() async throws {
    // Start consuming never() in an unstructured task
    let neverTask = Task {
      for await _ in never() as AsyncStream<Int> {
        return "emitted"
      }
      return "completed"
    }
    
    // Wait 10ms - if never() emitted or completed, the task would finish
    try await Task.sleep(nanoseconds: 10_000_000)
    
    // Cancel the never task since it will never complete on its own
    neverTask.cancel()
    
    // If we got here, never() didn't emit or complete within 10ms - test passes
  }
// unnamed ends here

// [[file:index.org::2663]]
  func testIterateGeneratesSequence() async throws {
    let values = await collect(take(5, iterate(1) { $0 * 2 }))
    XCTAssertEqual(values, [1, 2, 4, 8, 16])
  }

  func testIterateWithAddition() async throws {
    let values = await collect(take(4, iterate(0) { $0 + 1 }))
    XCTAssertEqual(values, [0, 1, 2, 3])
  }

  func testIterateWithStrings() async throws {
    let values = await collect(take(3, iterate("a") { $0 + "a" }))
    XCTAssertEqual(values, ["a", "aa", "aaa"])
  }
// unnamed ends here

// [[file:index.org::3125]]
  func testUnfoldGeneratesValues() async throws {
    let values = await collect(unfold(1) { n in
      UnfoldResult(value: n, nextSeed: n + 1, done: n > 3)
    })
    XCTAssertEqual(values, [1, 2, 3])
  }

  func testUnfoldStopsImmediatelyWhenDone() async throws {
    let values: [Int] = await collect(unfold(0) { _ in
      UnfoldResult(value: 999, nextSeed: 0, done: true)
    })
    XCTAssertTrue(values.isEmpty)
  }

  func testUnfoldWithDifferentTypes() async throws {
    let values = await collect(unfold(0) { n in
      UnfoldResult(value: "item-\(n)", nextSeed: n + 1, done: n >= 2)
    })
    XCTAssertEqual(values, ["item-0", "item-1"])
  }
// unnamed ends here

// [[file:index.org::3426]]
  func testStartWithPrependsValue() async throws {
    let values = await collect(startWith(0, from([1, 2, 3])))
    XCTAssertEqual(values, [0, 1, 2, 3])
  }

  func testStartWithOnEmptyStream() async throws {
    let values = await collect(startWith(42, empty()))
    XCTAssertEqual(values, [42])
  }
// unnamed ends here

// [[file:index.org::3819]]
  func testConcatJoinsStreams() async throws {
    let values = await collect(concat(from([1, 2]), from([3, 4])))
    XCTAssertEqual(values, [1, 2, 3, 4])
  }

  func testConcatWithEmptyFirst() async throws {
    let values = await collect(concat(empty(), from([5, 6])))
    XCTAssertEqual(values, [5, 6])
  }

  func testConcatArrayOfStreams() async throws {
    let values = await collect(concat([from([1]), from([2, 3]), from([4])]))
    XCTAssertEqual(values, [1, 2, 3, 4])
  }
// unnamed ends here

// [[file:index.org::4103]]
  func testCreateChannel() async throws {
    let (stream, channel): (AsyncStream<Int>, Channel<Int>) = createChannel()
    
    Task {
      channel.send(1)
      channel.send(2)
      channel.send(3)
      channel.finish()
    }
    
    let result = await collect(stream)
    XCTAssertEqual(result, [1, 2, 3])
  }
// unnamed ends here

// [[file:index.org::4680]]
  func testMapTransformsValues() async throws {
    let values = await collect(map({ $0 * 2 }, from([1, 2, 3])))
    XCTAssertEqual(values, [2, 4, 6])
  }

  func testMapWithTypeChange() async throws {
    let values = await collect(map({ "num-\($0)" }, from([1, 2, 3])))
    XCTAssertEqual(values, ["num-1", "num-2", "num-3"])
  }

  func testMapEmptyStream() async throws {
    let values: [Int] = await collect(map({ $0 * 2 }, empty()))
    XCTAssertTrue(values.isEmpty)
  }
// unnamed ends here

// [[file:index.org::4865]]
  func testConstantReplacesAllValues() async throws {
    let values = await collect(constant("x", from([1, 2, 3])))
    XCTAssertEqual(values, ["x", "x", "x"])
  }

  func testConstantEmptyStream() async throws {
    let emptyStream: AsyncStream<String> = empty()
    let values: [Int] = await collect(constant(42, emptyStream))
    XCTAssertTrue(values.isEmpty)
  }
// unnamed ends here

// [[file:index.org::5436]]
  func testScanAccumulatesWithSeed() async throws {
    let values = await collect(scan({ $0 + $1 }, 0, from([1, 2, 3])))
    XCTAssertEqual(values, [0, 1, 3, 6])
  }

  func testScanProduct() async throws {
    let values = await collect(scan({ $0 * $1 }, 1, from([2, 3, 4])))
    XCTAssertEqual(values, [1, 2, 6, 24])
  }

  func testScanEmptyStream() async throws {
    let values = await collect(scan({ $0 + $1 }, 100, from([Int]()))) 
    XCTAssertEqual(values, [100]) // Only seed
  }
// unnamed ends here

// [[file:index.org::5782]]
  func testTapPerformsSideEffect() async throws {
    actor Counter {
      var values: [Int] = []
      func append(_ value: Int) { values.append(value) }
      func getValues() -> [Int] { values }
    }
    let counter = Counter()
    let values = await collect(tap({ await counter.append($0) }, from([1, 2, 3])))
    XCTAssertEqual(values, [1, 2, 3])
    let sideEffects = await counter.getValues()
    XCTAssertEqual(sideEffects, [1, 2, 3])
  }
// unnamed ends here

// [[file:index.org::6108]]
  func testAwaitTapExecutesSideEffect() async throws {
    actor Counter {
      var count = 0
      func increment() { count += 1 }
      func getCount() -> Int { count }
    }
    let counter = Counter()
    let values = await collect(awaitTap({ (_: Int) in await counter.increment() }, from([1, 2, 3])))
    XCTAssertEqual(values, [1, 2, 3])
    let count = await counter.getCount()
    XCTAssertEqual(count, 3)
  }
// unnamed ends here

// [[file:index.org::6495]]
  func testContinueWithAppendsStream() async throws {
    let values = await collect(continueWith({ from([3, 4]) }, from([1, 2])))
    XCTAssertEqual(values, [1, 2, 3, 4])
  }

  func testContinueWithLazyEvaluation() async throws {
    actor Flag {
      var called = false
      func setCalled() { called = true }
      func wasCalled() -> Bool { called }
    }
    let flag = Flag()
    let values = await collect(continueWith({
      Task { await flag.setCalled() }
      return from([99])
    }, from([1])))
    XCTAssertEqual(values, [1, 99])
    // Note: flag may or may not be set depending on timing
  }
// unnamed ends here

// [[file:index.org::6790]]
  func testConcatAllFlattensStreams() async throws {
    let streamOfStreams = from([from([1, 2]), from([3, 4])])
    let values = await collect(concatAll(streamOfStreams))
    XCTAssertEqual(values, [1, 2, 3, 4])
  }
// unnamed ends here

// [[file:index.org::7143]]
  func testConcatMapSequential() async throws {
    let values = await collect(concatMap({ x in from([x * 10, x * 10 + 1]) }, from([1, 2])))
    XCTAssertEqual(values, [10, 11, 20, 21])
  }
// unnamed ends here

// [[file:index.org::7589]]
  func testFilterKeepsMatching() async throws {
    let values = await collect(filter({ $0 > 2 }, from([1, 2, 3, 4, 5])))
    XCTAssertEqual(values, [3, 4, 5])
  }

  func testFilterEvenNumbers() async throws {
    let values = await collect(filter({ $0 % 2 == 0 }, from([1, 2, 3, 4, 5, 6])))
    XCTAssertEqual(values, [2, 4, 6])
  }

  func testFilterEmptyResult() async throws {
    let values = await collect(filter({ $0 > 100 }, from([1, 2, 3])))
    XCTAssertTrue(values.isEmpty)
  }
// unnamed ends here

// [[file:index.org::8179]]
  func testSkipRepeatsRemovesDuplicates() async throws {
    let values = await collect(skipRepeats(from([1, 1, 2, 2, 3, 1, 1])))
    XCTAssertEqual(values, [1, 2, 3, 1])
  }

  func testSkipRepeatsWithCustomEquality() async throws {
    let values = await collect(skipRepeatsWith(
      { $0.lowercased() == $1.lowercased() },
      from(["A", "a", "B", "b"])
    ))
    XCTAssertEqual(values, ["A", "B"])
  }
// unnamed ends here

// [[file:index.org::8540]]
  func testTakeFirstN() async throws {
    let values = await collect(take(2, from([1, 2, 3, 4, 5])))
    XCTAssertEqual(values, [1, 2])
  }

  func testTakeMoreThanAvailable() async throws {
    let values = await collect(take(10, from([1, 2])))
    XCTAssertEqual(values, [1, 2])
  }

  func testTakeZero() async throws {
    let values = await collect(take(0, from([1, 2, 3])))
    XCTAssertTrue(values.isEmpty)
  }
// unnamed ends here

// [[file:index.org::8899]]
  func testSkipFirstN() async throws {
    let values = await collect(skip(2, from([1, 2, 3, 4, 5])))
    XCTAssertEqual(values, [3, 4, 5])
  }

  func testSkipZero() async throws {
    let values = await collect(skip(0, from([1, 2, 3])))
    XCTAssertEqual(values, [1, 2, 3])
  }

  func testSkipMoreThanAvailable() async throws {
    let values = await collect(skip(5, from([1, 2])))
    XCTAssertTrue(values.isEmpty)
  }
// unnamed ends here

// [[file:index.org::9288]]
  func testSliceExtractsRange() async throws {
    let values = await collect(slice(2, 5, from([0, 1, 2, 3, 4, 5])))
    XCTAssertEqual(values, [2, 3, 4])
  }

  func testSliceEmptyRange() async throws {
    let values = await collect(slice(2, 2, from([0, 1, 2, 3, 4])))
    XCTAssertTrue(values.isEmpty)
  }

  func testSliceBeyondLength() async throws {
    let values = await collect(slice(1, 10, from([0, 1, 2])))
    XCTAssertEqual(values, [1, 2])
  }
// unnamed ends here

// [[file:index.org::9676]]
  func testTakeWhile() async throws {
    let source = AsyncStream { c in c.yield(1); c.yield(2); c.yield(3); c.yield(4); c.yield(2); c.yield(1); c.finish() }
    let result = await collect(takeWhile { $0 < 4 }(source))
    XCTAssertEqual(result, [1, 2, 3])
  }

  func testTakeWhileAllPass() async throws {
    let source = from([1, 2, 3])
    let result = await collect(takeWhile { _ in true }(source))
    XCTAssertEqual(result, [1, 2, 3])
  }

  func testTakeWhileNonePass() async throws {
    let source = from([1, 2, 3])
    let result = await collect(takeWhile { _ in false }(source))
    XCTAssertEqual(result, [])
  }
// unnamed ends here

// [[file:index.org::10077]]
  func testSkipWhile() async throws {
    let source = from([1, 2, 3, 4, 2, 1])
    let result = await collect(skipWhile { $0 < 3 }(source))
    XCTAssertEqual(result, [3, 4, 2, 1])
  }

  func testSkipWhileAllFail() async throws {
    let source = from([1, 2, 3])
    let result = await collect(skipWhile { _ in false }(source))
    XCTAssertEqual(result, [1, 2, 3])
  }

  func testSkipWhileAllPass() async throws {
    let source = from([1, 2, 3])
    let result = await collect(skipWhile { _ in true }(source))
    XCTAssertEqual(result, [])
  }
// unnamed ends here

// [[file:index.org::10463]]
  func testTakeUntil() async throws {
    let source = from([1, 2, 3, 4, 5])
    let result = await collect(takeUntil { $0 == 3 }(source))
    XCTAssertEqual(result, [1, 2])
  }

  func testTakeUntilNeverMatches() async throws {
    let source = from([1, 2, 3])
    let result = await collect(takeUntil { _ in false }(source))
    XCTAssertEqual(result, [1, 2, 3])
  }

  func testTakeUntilFirstMatches() async throws {
    let source = from([1, 2, 3])
    let result = await collect(takeUntil { $0 == 1 }(source))
    XCTAssertEqual(result, [])
  }
// unnamed ends here

// [[file:index.org::10698]]
  func testDelay() async throws {
    let source = from([1, 2, 3])
    let start = ContinuousClock.now
    let result = await collect(delay(10)(source))
    let elapsed = ContinuousClock.now - start
    XCTAssertEqual(result, [1, 2, 3])
    XCTAssertTrue(elapsed >= .milliseconds(25)) // ~30ms for 3 items
  }

  func testDelayEmptyStream() async throws {
    let source: AsyncStream<Int> = empty()
    let result = await collect(delay(100)(source))
    XCTAssertEqual(result, [])
  }
// unnamed ends here

// [[file:index.org::11431]]
// Note: Debounce tests require time-based testing with controlled timing
// The implementation follows the same pattern as other languages
// unnamed ends here

// [[file:index.org::12151]]
  func testThrottleLeading() async throws {
    let source = from([1, 2, 3, 4, 5])
    let result = await collect(throttle(100, .leadingOnly())(source))
    // First value should be emitted immediately
    XCTAssertFalse(result.isEmpty)
    XCTAssertEqual(result[0], 1)
  }

  func testThrottleTrailing() async throws {
    let source = from([1, 2, 3])
    let result = await collect(throttle(100, .trailingOnly())(source))
    // Last value should be emitted as trailing
    XCTAssertFalse(result.isEmpty)
  }

  func testThrottleEmpty() async throws {
    let source: AsyncStream<Int> = empty()
    let result = await collect(throttle(100)(source))
    XCTAssertEqual(result, [])
  }
// unnamed ends here

// [[file:index.org::12649]]
struct SimpleError: Error {}

  func testRecoverWithNoError() async throws {
    let source = AsyncThrowingStream<Int, any Error> { c in c.yield(1); c.yield(2); c.yield(3); c.finish() }
    let result = await collect(recoverWith { _ in from([99]) }(source))
    XCTAssertEqual(result, [1, 2, 3])
  }

  func testRecoverWithError() async throws {
    let source = AsyncThrowingStream<Int, any Error> { c in c.yield(1); c.finish(throwing: SimpleError()) }
    let result = await collect(recoverWith { _ in from([99, 100]) }(source))
    XCTAssertEqual(result, [1, 99, 100])
  }
// unnamed ends here

// [[file:index.org::12837]]
  func testRecoverWithStreamSuccess() async throws {
    let source = AsyncThrowingStream<Int, any Error> { c in c.yield(1); c.yield(2); c.yield(3); c.finish() }
    let alts: AsyncStream<AsyncStream<Int>> = empty()
    let result = await collect(recoverWithStream(alts)(source))
    XCTAssertEqual(result, [1, 2, 3])
  }

  func testRecoverWithStreamUsesAlternative() async throws {
    let source = AsyncThrowingStream<Int, any Error> { c in c.yield(1); c.finish(throwing: SimpleError()) }
    let alt = from([10, 20])
    let alts = just(alt)
    let result = await collect(recoverWithStream(alts)(source))
    XCTAssertEqual(result, [1, 10, 20])
  }
// unnamed ends here

// [[file:index.org::13088]]
  func testThrowErrorEmitsError() async throws {
    let stream: AsyncThrowingStream<Int, any Error> = throwError(SimpleError())
    var gotError = false
    do {
      for try await _ in stream {
        // Should not get here
      }
    } catch {
      gotError = true
    }
    XCTAssertTrue(gotError)
  }
// unnamed ends here

// [[file:index.org::13835]]
  func testRetryWithSuccess() async throws {
    let results = await collect(retry(3) {
      AsyncThrowingStream { c in c.yield(1); c.yield(2); c.yield(3); c.finish() }
    })
    let values = results.compactMap { try? $0.get() }
    XCTAssertEqual(values, [1, 2, 3])
  }

  func testRetryWithEventualSuccess() async throws {
    actor Attempts {
      var count = 0
      func increment() -> Int {
        count += 1
        return count
      }
    }
    let attempts = Attempts()
    
    let results = await collect(retry(3) {
      AsyncThrowingStream<Int, any Error> { c in
        Task {
          let n = await attempts.increment()
          if n < 3 {
            c.finish(throwing: SimpleError())
          } else {
            c.yield(42)
            c.finish()
          }
        }
      }
    })
    let values = results.compactMap { try? $0.get() }
    XCTAssertEqual(values, [42])
  }
// unnamed ends here

// [[file:index.org::14402]]
  func testMerge() async throws {
    let s1 = from([1, 3, 5])
    let s2 = from([2, 4, 6])
    let result = await collect(merge(s1, s2))
    // Order may vary, but all values should be present
    XCTAssertEqual(result.count, 6)
    XCTAssertTrue(result.contains(1))
    XCTAssertTrue(result.contains(6))
  }

  func testMergeAll() async throws {
    let streams = [from([1, 2]), from([3, 4])]
    let result = await collect(mergeAll(streams))
    XCTAssertEqual(result.count, 4)
  }
// unnamed ends here

// [[file:index.org::14977]]
  func testChainFlattens() async throws {
    let source = from([1, 2])
    let result = await collect(chain { x in from([x * 10, x * 10 + 1]) }(source))
    // With concurrent execution, order may vary
    XCTAssertEqual(Set(result), Set([10, 11, 20, 21]))
  }
// unnamed ends here

// [[file:index.org::15182]]
  func testChainFlattens() async throws {
    let source = from([1, 2])
    let result = await collect(chain { x in from([x * 10, x * 10 + 1]) }(source))
    // With concurrent execution, order may vary
    XCTAssertEqual(Set(result), Set([10, 11, 20, 21]))
  }
// unnamed ends here

// [[file:index.org::15705]]
  func testSwitchMapSwitches() async throws {
    // With synchronous inner streams, switchMap behaves like concatMap
    // True switching requires async timing
    let source = from([1, 2])
    let result = await collect(switchMap { x in from([x * 10]) }(source))
    // May see values from both or just last depending on timing
    XCTAssertFalse(result.isEmpty)
  }
// unnamed ends here

// [[file:index.org::16137]]
  func testLatestCombines() async throws {
    let s1 = from([1, 2])
    let s2 = from(["a", "b"])
    let result = await collect(latest(s1, s2))
    // Should emit tuples when both have values
    XCTAssertFalse(result.isEmpty)
  }
// unnamed ends here

// [[file:index.org::16410]]
  func testApplyLatest() async throws {
    let double: @Sendable (Int) -> Int = { x in x * 2 }
    let addTen: @Sendable (Int) -> Int = { x in x + 10 }
    let fns = from([double, addTen])
    let vals = from([1, 2, 3])
    let result = await collect(applyLatest(fns, vals))
    // Should apply latest function to latest value
    XCTAssertFalse(result.isEmpty)
  }
// unnamed ends here

// [[file:index.org::16784]]
// Note: untilStream requires Atomics package or actor-based implementation
// Test implementation depends on the chosen approach
// unnamed ends here

// [[file:index.org::17142]]
  func testSinceStreamWaits() async throws {
    let source = from([1, 2, 3, 4])
    let start = just(())
    let result = await collect(sinceStream(start)(source))
    // Should emit values after start signal
    XCTAssertFalse(result.isEmpty)
  }
// unnamed ends here

// [[file:index.org::17501]]
  func testBuffer() async throws {
    let source = from([1, 2, 3, 4, 5])
    let result = await collect(buffer(2)(source))
    XCTAssertEqual(result, [[1, 2], [3, 4], [5]])
  }

  func testBufferExactMultiple() async throws {
    let source = from([1, 2, 3, 4])
    let result = await collect(buffer(2)(source))
    XCTAssertEqual(result, [[1, 2], [3, 4]])
  }

  func testBufferEmpty() async throws {
    let source: AsyncStream<Int> = empty()
    let result = await collect(buffer(3)(source))
    XCTAssertEqual(result, [])
  }
// unnamed ends here

// [[file:index.org::17982]]
// Note: bufferTime tests require timing control
// Basic timing logic follows the same pattern as other time-based operators
// unnamed ends here

// [[file:index.org::18309]]
  func testWindow() async throws {
    let source = from([1, 2, 3, 4, 5])
    let result = await collect(window(2)(source))
    XCTAssertEqual(result, [[1, 2], [3, 4], [5]])
  }
// unnamed ends here

// [[file:index.org::18918]]
// Note: eager tests require timing control to verify pre-fetching behavior
// The implementation follows a pattern of background buffering
// unnamed ends here

// [[file:index.org::19408]]
  func testReplaySubjectBuffer() async throws {
    let subject = ReplaySubject<Int>(bufferSize: 2)
    
    await subject.next(1)
    await subject.next(2)
    await subject.next(3)  // 1 should be evicted
    await subject.complete()
    
    let values = await collect(await subject.subscribe())
    XCTAssertEqual(values, [2, 3])
  }

  func testReplaySubjectEmpty() async throws {
    let subject = ReplaySubject<Int>(bufferSize: 5)
    await subject.complete()
    
    let values = await collect(await subject.subscribe())
    XCTAssertEqual(values, [])
  }

  func testReplaySubjectUnlimited() async throws {
    let subject = ReplaySubject<Int>(bufferSize: Int.max)
    
    await subject.next(1)
    await subject.next(2)
    await subject.next(3)
    await subject.complete()
    
    let values = await collect(await subject.subscribe())
    XCTAssertEqual(values, [1, 2, 3])
  }
// unnamed ends here

// [[file:index.org::19996]]
  func testReplayBuffered() async throws {
    let source = from([1, 2, 3, 4, 5])
    let replayed = Replay(bufferSize: 2, source)
    
    // Subscribe and consume
    let stream = await replayed.subscribe()
    let values = await collect(stream)
    XCTAssertEqual(values, [1, 2, 3, 4, 5])
  }
// unnamed ends here

// [[file:index.org::20339]]
  func testShareBasic() async throws {
    let source = from([1, 2, 3])
    let shared = share(source)
    
    let stream = await shared.subscribe()
    let values = await collect(stream)
    XCTAssertEqual(values, [1, 2, 3])
  }
// unnamed ends here

// [[file:index.org::20766]]
  func testReplayFactory() async throws {
    let source = from([1, 2, 3])
    let factory = replayFactory(2, source)
    
    let stream = await factory()
    let values = await collect(stream)
    XCTAssertEqual(values, [1, 2, 3])
  }
// unnamed ends here

// [[file:index.org::20940]]
  func testReplayStream() async throws {
    let source = from([1, 2, 3])
    let copies = replayStream(Int.max, source)
    
    // Get first copy
    var count = 0
    for await copy in copies {
      let values = await collect(copy)
      XCTAssertEqual(values, [1, 2, 3])
      count += 1
      if count >= 1 { break }
    }
  }
}
// unnamed ends here
